1.定义
代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
通俗的来讲代理模式就是我们生活中常见的中介。
举个例子来说明：假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，
但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？
于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，
然后付钱就可以了。


2.为什么要用代理模式？
中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，
而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。

开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，
这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。
代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。
代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。
真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。
例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。


3.有哪几种代理模式？
 我们有多种不同的方式来实现代理。如果按照代理创建的时期来进行分类的话，
 可以分为两种：静态代理、动态代理。
 静态代理是由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了。
 动态代理是在程序运行时通过反射机制动态创建的。

静态代理总结：
优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。
缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。


动态代理总结：
虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。
但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。
回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。
Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。
有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。
接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。
如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。
实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，
它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。
但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。














